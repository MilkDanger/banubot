{"version":3,"sources":["webpack:///./src/pages/flashcards/index.js"],"names":["Sides","rus","eng","this","className","styles","flashbod","Card","props","cardDiv","React","createRef","prev","nxt","lang","sort","state","cardTxt","posTxt","decks","cards","i","flipped","loaded","sorted","all","add","push","update","setState","length","flip","next","amt","flipdate","deckify","links","Deck","name","key","changeDeck","index","console","log","switchLang","getCardInfo","data","allTestJson","edges","forEach","item","node","componentDidMount","current","addEventListener","me","onclick","handleEvent","e","render","type","ref","pos","cardText","query","Component","func","window","scrollTo","deck","onClick","src","alt","cardPic","deckName"],"mappings":"kTAmBA,SAASA,EAAMC,EAAKC,GAClBC,KAAKD,IAAMA,EACXC,KAAKF,IAAMA,EAZE,4BACd,6BACC,kBAAC,IAAD,KACI,0BAAMG,UAAWC,IAAOC,YAE5B,kBAACC,EAAD,Q,IAWIA,E,YAEL,WAAYC,GAAQ,IAAD,SAClB,cAAMA,IAAN,MAKKC,QAAUC,IAAMC,YACrB,EAAKC,KAAOF,IAAMC,YAClB,EAAKE,IAAMH,IAAMC,YACjB,EAAKG,KAAOJ,IAAMC,YAClB,EAAKI,KAAOL,IAAMC,YAIlB,EAAKK,MAAQ,CACZC,QAAS,GACTC,OAAQ,MACRC,MAAO,IAIR,EAAKC,MAAQ,GAEb,EAAKC,EAAI,EAGT,EAAKpB,KAAM,EAEX,EAAKqB,SAAU,EAEf,EAAKC,QAAS,EAEd,EAAKC,QAAS,EAEd,EAAKC,IAAM,GAlCO,E,kCAsCnBC,IAAA,SAAIzB,EAAKC,GACRC,KAAKiB,MAAMO,KAAK,IAAI3B,EAAMC,EAAKC,K,EAKhC0B,OAAA,WACCzB,KAAK0B,SAAS,CACbZ,QAASd,KAAKF,IAAME,KAAKiB,MAAMjB,KAAKkB,GAAGpB,IAAME,KAAKiB,MAAMjB,KAAKkB,GAAGnB,IAChEgB,OAASf,KAAKkB,EAAI,EAAK,IAAMlB,KAAKiB,MAAMU,U,EAK1CC,KAAA,WACC5B,KAAKF,KAAOE,KAAKF,IACjBE,KAAKmB,SAAWnB,KAAKmB,QACrBnB,KAAKyB,U,EAINI,KAAA,SAAKC,GACA9B,KAAKiB,MAAMU,OAAS,IACvB3B,KAAKkB,GAAKlB,KAAKkB,EAAIY,GAAO9B,KAAKiB,MAAMU,OAEjC3B,KAAKkB,EAAI,IACZlB,KAAKkB,EAAIlB,KAAKiB,MAAMU,OAAS,GAI9B3B,KAAK+B,a,EAOPA,SAAA,WACK/B,KAAKmB,QACRnB,KAAK4B,OAEL5B,KAAKyB,U,EAMPO,QAAA,WACC,IAAId,EAGJ,IAAKA,EAAI,EAAGA,EAAIlB,KAAKiB,MAAMU,OAAQT,IAClClB,KAAKsB,IAAIE,KAAKxB,KAAKiB,MAAMC,IAG1B,IAAIe,EAAQ,GACZ,IAAKf,EAAI,GAAIA,EAAIlB,KAAKsB,IAAIK,OAAQT,GAAG,GACpCe,EAAMT,KAAK,kBAACU,EAAD,CAAMC,KAAMjB,EAAGkB,IAAKlB,EAAGD,MAAOjB,QAG1CA,KAAKqC,WAAW,IAChBrC,KAAK0B,SAAS,CACbV,MAAOiB,K,EAMTI,WAAA,SAAWC,GAGV,IAAIpB,EAEJ,IAHAlB,KAAKiB,MAAQ,GAEbsB,QAAQC,IAAI,iBAAmBF,GAC1BpB,EAAIoB,EAAQ,GAAIpB,EAAIoB,EAAOpB,IAC/BlB,KAAKiB,MAAMO,KAAKxB,KAAKsB,IAAIJ,IAE1BlB,KAAKkB,EAAI,EACTlB,KAAK+B,Y,EAINU,WAAA,WACCzC,KAAKF,KAAOE,KAAKF,IACjBE,KAAKyB,U,EAMNiB,YAAA,SAAYC,GAAO,IAAD,OACZ3C,KAAKoB,SACTpB,KAAKuB,IAAI,iCAAiC,sBAC1CoB,EAAKC,YAAYC,MAAMC,SAAQ,SAAAC,GAC9B,EAAKxB,IAAIwB,EAAKC,KAAKlD,IAAIiD,EAAKC,KAAKjD,QAElCC,KAAKoB,QAAS,I,EAMhB6B,kBAAA,WACCjD,KAAKyB,SACLzB,KAAKM,QAAQ4C,QAAQC,iBAAiB,QAASnD,MAE/C,IAAIoD,EAAKpD,KACTA,KAAKS,KAAKyC,QAAQG,QAAU,WAAYD,EAAGvB,MAAM,IACjD7B,KAAKU,IAAIwC,QAAQG,QAAU,WAAYD,EAAGvB,KAAK,IAC/C7B,KAAKW,KAAKuC,QAAQG,QAAU,WAAYD,EAAGX,cAC3CzC,KAAKY,KAAKsC,QAAQG,QAAU,WAAYD,EAAGpB,Y,EAI5CsB,YAAA,SAAYC,GACVvD,KAAK4B,Q,EAKP4B,OAAA,WAAU,IAAD,OACR,OACC,6BACC,gCACC,4BAAQC,KAAK,SAASxD,UAAWC,IAAO0B,KAAM8B,IAAK1D,KAAKW,MAAxD,aACA,6BACA,4BAAQ8C,KAAK,SAASC,IAAK1D,KAAKS,MAAhC,WACA,uBAAGR,UAAWC,IAAOyD,KAAM3D,KAAKa,MAAME,QACtC,4BAAQ0C,KAAK,SAASC,IAAK1D,KAAKU,KAAhC,aACA,yBAAKT,UAAWC,IAAO0D,SAAUF,IAAK1D,KAAKM,SACzCN,KAAKa,MAAMC,SAEb,6BACC,4BAAQ2C,KAAK,SAASC,IAAK1D,KAAKY,MAAhC,eACA,6BACCZ,KAAKa,MAAMG,QAGd,kBAAC,IAAD,CACC6C,MAAK,aAaNL,OAAQ,SAAAb,GAAI,OACX,6BACE,EAAKD,YAAYC,KAhBpB,W,GAjLemB,aA+Mb5B,E,YACL,WAAY7B,GAAQ,IAAD,GAClB,cAAMA,IAAN,MAIKY,MAAQZ,EAAMY,MACnB,EAAKkB,KAAO9B,EAAM8B,KAClB,IAAIiB,E,yHAAE,IAPY,OAUlB,EAAKW,KAAO,WACX1D,EAAMY,MAAMoB,WAAWe,EAAGjB,MAC1B6B,OAAOC,SAAS,EAAE,IAZD,E,0BAiBnBT,OAAA,WACC,OACC,yBAAKvD,UAAWC,IAAOgE,KAAMC,QAASnE,KAAK+D,MAC1C,yBAAKK,IAAI,eAAeC,IAAI,OAAOpE,UAAWC,IAAOoE,UACrD,yBAAKrE,UAAWC,IAAOqE,UAAWvE,KAAKmC,Q,GAtBxB2B,c","file":"component---src-pages-flashcards-index-js-9973d5676bd24a1e999d.js","sourcesContent":["/* Hannah Parraga\n * Russian flashcards website with cards taken\n * from the 10000 most common words (I deleted ones I know)\n */\nimport React, { Component } from \"react\"\nimport { StaticQuery, graphql } from \"gatsby\"\nimport Helmet from 'react-helmet'\nimport styles from \"../../components/flashcards-container.module.css\"\n\nexport default () => (\n\t<div>\n\t\t<Helmet>\n    \t\t<body className={styles.flashbod} />\n\t\t</Helmet>\n\t\t<Card />\n\t</div>\n);\n\n//2 sides for every card\nfunction Sides(rus, eng) {\n\t\tthis.eng = eng;\n\t\tthis.rus = rus;\n}\n\n//The big white square with the words in it\nclass Card extends Component {\n\t//give properties to react component constructor\n\tconstructor(props) {\n\t\tsuper(props);\n\t\n\t\t//references to the div where the\n\t\t//words are and the change card buttons\n\t\t//to change the text\n\t\tthis.cardDiv = React.createRef();\n\t\tthis.prev = React.createRef();\n\t\tthis.nxt = React.createRef();\n\t\tthis.lang = React.createRef();\n\t\tthis.sort = React.createRef();\n\n\t\t//card text and position number text\n\t\t//goes in div\n\t\tthis.state = {\t\n\t\t\tcardTxt: \"\",\n\t\t\tposTxt: \"0/0\",\n\t\t\tdecks: [],\n\t\t};\n\t\t\n\t\t//array of all possible cards\n\t\tthis.cards = [];\n\t\t//current card index\n\t\tthis.i = 0;\n\t\t//are we on the russian side? \n\t\t//either bc rus side up or bc flipped\n\t\tthis.rus = true;\n\t\t//card was flipped\n\t\tthis.flipped = false;\n\t\t//already grabbed the cards from json?\n\t\tthis.loaded = false;\n\t\t//don't sort more than once\n\t\tthis.sorted = false;\n\t\t//storage for cards if decks\n\t\tthis.all = [];\n\t}\n\n\t//put a new card in the master array\n\tadd(rus, eng) {\n\t\tthis.cards.push(new Sides(rus, eng));\n\t}\n\n\t//pick the rus or eng side of the card at \n\t//current index and update the text\n\tupdate() {\n\t\tthis.setState({\n\t\t\tcardTxt: this.rus ? this.cards[this.i].rus : this.cards[this.i].eng,\n\t\t\tposTxt: (this.i + 1) + \"/\" + this.cards.length\n\t\t});\n\t}\n\n\t//swap sides and update\n\tflip() {\n\t\tthis.rus = !this.rus;\n\t\tthis.flipped = !this.flipped;\n\t\tthis.update();\n\t}\n\n\t//move the card index forward or back \n\tnext(amt) {\n\t\tif (this.cards.length > 0) {\n\t\t\tthis.i = (this.i + amt) % this.cards.length;\n\t\t\t//wrap around\n\t\t\tif (this.i < 0) {\n\t\t\t\tthis.i = this.cards.length - 1;\n\t\t\t}\n\t\t\t//if you flipped over the card last time,\n\t\t\t//this one shouldn't be flipped too\n\t\t\tthis.flipdate();\n\t\t}\n\t}\n\n\n\t//flip sides before updating or no\n\t//for when deck or language changes\n\tflipdate() {\n\t\tif (this.flipped) {\n\t\t\tthis.flip()\n\t\t} else {\n\t\t\tthis.update();\n\t\t}\n\t}\n\n\t//take all the cars and split them into decks \n\t//with 10 cards each\n\tdeckify() {\n\t\tvar i;\n\t\t//save all the cards so they can be grabbed when \n\t\t//deck changes\n\t\tfor (i = 0; i < this.cards.length; i++) {\n\t\t\tthis.all.push(this.cards[i]);\n\t\t}\n\t\t//fill array with deck components\n\t\tvar links = [];\n\t\tfor (i = 10; i < this.all.length; i+=10) {\n\t\t\tlinks.push(<Deck name={i} key={i} cards={this}/>);\n\t\t}\n\t\t//go back to first deck\n\t\tthis.changeDeck(10);\n\t\tthis.setState({\n\t\t\tdecks: links\n\t\t});\n\t}\n\n\t//change the card to be 10 cards from index - 10\n\t//to index\n\tchangeDeck(index) {\n\t\t//empty current cards\n\t\tthis.cards = [];\n\t\tvar i;\n\t\tconsole.log(\"current deck: \" + index);\n\t\tfor (i = index - 10; i < index; i++) {\n\t\t\tthis.cards.push(this.all[i]);\n\t\t}\n\t\tthis.i = 0;\n\t\tthis.flipdate();\n\t}\n\t\n\t//change all cards to be other language side up\n\tswitchLang() {\n\t\tthis.rus = !this.rus;\n\t\tthis.update();\n\t}\n\n\n\t//load up all the cards from the json and add them \n\t//to the array\n\tgetCardInfo(data) {\n\t\tif (!this.loaded) {\n\t\t\tthis.add(\"Нажмите карточку чтобы щелкать\",\"Click card to flip\");\n\t\t\tdata.allTestJson.edges.forEach(item => {\n\t\t\t\tthis.add(item.node.rus,item.node.eng);\n\t\t\t});\n\t\t\tthis.loaded = true;\n\t\t}\n\t}\n\n\t//if this react component was made successfully\n\t//then add click handlers to the card div and buttons\n\tcomponentDidMount() {\n\t\tthis.update();\n\t\tthis.cardDiv.current.addEventListener('click', this) \n\t\t//preserve who \"this\" is inside function\n\t\tvar me = this;\n\t\tthis.prev.current.onclick = function() {me.next(-1);};\n\t\tthis.nxt.current.onclick = function() {me.next(1);};\n\t\tthis.lang.current.onclick = function() {me.switchLang();};\n\t\tthis.sort.current.onclick = function() {me.deckify();};\n\t}\n\t\n\t//card div was clicked\n\thandleEvent(e) {\n\t  this.flip()\n\t}\n\n\t//this is what card and buttons should look like\n\t//StaticQuery is the query to get the json info\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<center>\n\t\t\t\t\t<button type=\"button\" className={styles.flip} ref={this.lang}>рус - анг</button>\n\t\t\t\t\t<br/>\n\t\t\t\t\t<button type=\"button\" ref={this.prev}>прошлая</button>\n\t\t\t\t\t<p className={styles.pos}>{this.state.posTxt}</p>\n\t\t\t\t\t<button type=\"button\" ref={this.nxt}>следующая</button>\n\t\t\t\t\t<div className={styles.cardText} ref={this.cardDiv}>\n\t\t\t\t\t\t{this.state.cardTxt}\n\t\t\t\t\t</div>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<button type=\"button\" ref={this.sort}>сортировать</button>\n\t\t\t\t\t\t<br/>\n\t\t\t\t\t\t{this.state.decks}\n\t\t\t\t\t</div>\n\t\t\t\t</center>\n\t\t\t\t<StaticQuery\n\t\t\t\t\tquery={\n\t\t\t\t\t\tgraphql`\n\t\t\t\t\t\t  query CardQuery {\n\t\t\t\t\t\t\tallTestJson {\n\t\t\t\t\t\t\t  edges {\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\trus\n\t\t\t\t\t\t\t\t\teng\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t  }\n\t\t\t\t`}\n\t\t\t\trender={data => (\n\t\t\t\t\t<div>\n\t\t\t\t\t\t{this.getCardInfo(data)}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t  />\n\t\t\t</div>\n\t\t)\n\t}\n}\n\n//all the buttons that show up when you\n//hit the sort button\n//each deck will have 10 words in it just because \n//I think that's a pretty manageable amount of words\n//to learn at once\nclass Deck extends Component {\n\tconstructor(props) {\n\t\tsuper(props); \n\t\t//each deck component has a reference to\n\t\t//the card component so it can tell the \n\t\t//card comp. to change to its cards\n\t\tthis.cards = props.cards;\n\t\tthis.name = props.name;\n\t\tvar me = this;\n\t\t//when this deck button is clicked,\n\t\t//change cards to cards of this deck\n\t\tthis.func = function() {\n\t\t\tprops.cards.changeDeck(me.name);\n\t\t\twindow.scrollTo(0,0);\n\t\t};\n\t}\n\t\n\t//each has a deck pic and the number\n\trender() {\n\t\treturn (\n\t\t\t<div className={styles.deck} onClick={this.func}>\n\t\t\t\t<img src=\"../cards.png\" alt=\"deck\" className={styles.cardPic}/>\n\t\t\t\t<div className={styles.deckName}>{this.name}</div>\n\t\t\t</div>\n\t\t)\n\t}\n}\n"],"sourceRoot":""}